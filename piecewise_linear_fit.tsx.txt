import React, { useState } from 'react';
import { ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';
import { Upload, Play, Trash2 } from 'lucide-react';

export default function PiecewiseLinearInterpolation() {
  const [points, setPoints] = useState([]);
  const [segments, setSegments] = useState([]);
  const [inputText, setInputText] = useState('');

  const parseInput = (text) => {
    const lines = text.trim().split('\n');
    const parsed = [];
    for (let line of lines) {
      const parts = line.trim().split(/[\s,;]+/);
      if (parts.length >= 2) {
        const x = parseFloat(parts[0]);
        const y = parseFloat(parts[1]);
        if (!isNaN(x) && !isNaN(y)) {
          parsed.push({ x, y });
        }
      }
    }
    // مرتب‌سازی اولیه بر اساس X برای اطمینان از اتصال صحیح
    return parsed.sort((a, b) => a.x - b.x);
  };

  const findNearestToYAxis = (pts) => {
    if (pts.length === 0) return null;
    let nearest = pts[0];
    let minX = Math.abs(pts[0].x);
    for (let pt of pts) {
      if (Math.abs(pt.x) < minX) {
        minX = Math.abs(pt.x);
        nearest = pt;
      }
    }
    return nearest;
  };

  const handleLoadData = () => {
    const parsed = parseInput(inputText);
    if (parsed.length > 0) {
      setPoints(parsed);
      setSegments([]);
    }
  };

  // ***** تابع اصلی تغییر یافته: اجرای میان‌یابی خطی *****
  const performInterpolation = () => {
    if (points.length < 2) {
      setSegments([]);
      return;
    }

    // چون parseInput قبلاً نقاط را بر اساس X مرتب کرده، نیاز به مرتب‌سازی دوباره نیست.
    const newSegments = [];

    // حلقه از اولین نقطه تا نقطه ماقبل آخر
    for (let i = 0; i < points.length - 1; i++) {
      const p1 = points[i];
      const p2 = points[i + 1];
      
      // اگر دو نقطه مختصات X یکسان داشته باشند، شیب نامحدود است
      if (p2.x === p1.x) {
        newSegments.push({
          id: i + 1,
          slope: '∞',
          intercept: 'N/A',
          r2: '1.0000', // دقت کامل، چون نقاط دقیقا وصل شده‌اند
          xRange: `[${p1.x.toFixed(2)}, ${p2.x.toFixed(2)}]`,
          lineData: [p1, p2],
        });
        continue;
      }

      // 1. محاسبه شیب (m)
      const slope = (p2.y - p1.y) / (p2.x - p1.x);
      
      // 2. محاسبه عرض از مبدأ (b)
      // y = m*x + b  =>  b = y - m*x
      const intercept = p1.y - slope * p1.x;
      
      newSegments.push({
        id: i + 1,
        slope: slope.toFixed(4),
        intercept: intercept.toFixed(4),
        r2: '1.0000', // دقت کامل (میان‌یابی)، چون خط دقیقاً از دو نقطه می‌گذرد
        xRange: `[${p1.x.toFixed(2)}, ${p2.x.toFixed(2)}]`,
        lineData: [p1, p2]
      });
    }

    setSegments(newSegments);
  };

  const generateSampleData = () => {
    // ایجاد داده‌های نمونه (همانند قبل)
    const sample = [];
    for (let i = 0; i < 50; i++) {
      const x = i * 0.5;
      let y;
      if (x < 8) {
        y = 2 * x + 3 + (Math.random() - 0.5) * 2;
      } else if (x < 16) {
        y = -1 * x + 30 + (Math.random() - 0.5) * 2;
      } else {
        y = 0.5 * x + 5 + (Math.random() - 0.5) * 2;
      }
      sample.push({ x: x.toFixed(2), y: y.toFixed(2) });
    }
    // مرتب‌سازی برای اطمینان از اتصال صحیح در نمونه
    sample.sort((a, b) => parseFloat(a.x) - parseFloat(b.x));
    setInputText(sample.map(p => `${p.x} ${p.y}`).join('\n'));
  };

  const nearest = points.length > 0 ? findNearestToYAxis(points) : null;

  return (
    <div className="w-full h-screen bg-gradient-to-br from-slate-900 to-slate-800 p-6 overflow-auto">
      <div className="max-w-7xl mx-auto">
        <h1 className="text-3xl font-bold text-white mb-6">میان‌یابی خطی قطعه‌ای (Piecewise Linear Interpolation)</h1>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
          {/* Input Section */}
          <div className="lg:col-span-1 bg-slate-800 rounded-lg p-4 shadow-xl border border-slate-700">
            <h2 className="text-xl font-semibold text-white mb-4">ورودی داده‌ها</h2>
            
            <textarea
              className="w-full h-48 bg-slate-900 text-white p-3 rounded border border-slate-600 font-mono text-sm mb-3"
              placeholder="هر خط: x y (نقاط بر اساس X مرتب می‌شوند)&#10;مثال:&#10;0 3&#10;1 5&#10;2 7"
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
            />
            
            <div className="flex gap-2 mb-4">
              <button
                onClick={handleLoadData}
                className="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded flex items-center justify-center gap-2"
              >
                <Upload size={18} />
                بارگذاری
              </button>
              <button
                onClick={generateSampleData}
                className="flex-1 bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded"
              >
                نمونه
              </button>
              <button
                onClick={() => { setPoints([]); setSegments([]); setInputText(''); }}
                className="bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded"
              >
                <Trash2 size={18} />
              </button>
            </div>

            <button
              onClick={performInterpolation}
              disabled={points.length < 2}
              className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 text-white py-2 px-4 rounded flex items-center justify-center gap-2"
            >
              <Play size={18} />
              محاسبه خطوط (میان‌یابی)
            </button>

            {nearest && (
              <div className="mt-4 bg-slate-900 p-3 rounded border border-green-500">
                <p className="text-green-400 text-sm font-semibold">نزدیک‌ترین به محور Y:</p>
                <p className="text-white text-sm">x = {nearest.x.toFixed(3)}, y = {nearest.y.toFixed(3)}</p>
              </div>
            )}

            {points.length > 0 && (
              <div className="mt-3 text-slate-400 text-sm">
                تعداد نقاط: {points.length} (تعداد بخش‌ها: {segments.length})
              </div>
            )}
          </div>

          {/* Chart Section */}
          <div className="lg:col-span-2 bg-slate-800 rounded-lg p-4 shadow-xl border border-slate-700">
            <h2 className="text-xl font-semibold text-white mb-4">نمودار</h2>
            
            {points.length > 0 ? (
              <ScatterChart width={700} height={400}>
                <CartesianGrid strokeDasharray="3 3" stroke="#475569" />
                <XAxis type="number" dataKey="x" stroke="#94a3b8" domain={['dataMin', 'dataMax']} />
                <YAxis type="number" dataKey="y" stroke="#94a3b8" domain={['auto', 'auto']} />
                <Tooltip 
                  contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #475569' }}
                  labelStyle={{ color: '#fff' }}
                />
                <Legend />
                {/* نقاط ورودی به صورت پراکنده */}
                <Scatter name="نقاط داده" data={points} fill="#3b82f6" />
                
                {/* خطوط میان‌یابی */}
                {segments.map((seg, idx) => (
                  <Scatter
                    key={idx}
                    name={`خط ${seg.id}`}
                    data={seg.lineData}
                    // استفاده از رنگ برای هر بخش
                    fill={`hsl(${idx * 360 / segments.length}, 70%, 50%)`}
                    line={{ stroke: `hsl(${idx * 360 / segments.length}, 70%, 50%)`, strokeWidth: 3 }}
                    lineType="joint" // وصل کردن دو نقطه با خط
                    shape="none" // عدم نمایش نقطه Scatter
                  />
                ))}
              </ScatterChart>
            ) : (
              <div className="h-96 flex items-center justify-center text-slate-500">
                داده‌ای برای نمایش وجود ندارد
              </div>
            )}
          </div>
        </div>

        {/* Results Section */}
        {segments.length > 0 && (
          <div className="bg-slate-800 rounded-lg p-4 shadow-xl border border-slate-700">
            <h2 className="text-xl font-semibold text-white mb-4">نتایج محاسبات (میان‌یابی)</h2>
            <div className="overflow-x-auto">
              <table className="w-full text-left text-sm">
                <thead className="bg-slate-900 text-slate-300">
                  <tr>
                    <th className="p-3">بخش</th>
                    <th className="p-3">بازه X</th>
                    <th className="p-3">شیب (Slope)</th>
                    <th className="p-3">عرض از مبدا (Intercept)</th>
                    <th className="p-3">دقت (R²)</th>
                    <th className="p-3">معادله خط</th>
                  </tr>
                </thead>
                <tbody className="text-white">
                  {segments.map((seg, idx) => (
                    <tr key={idx} className="border-b border-slate-700 hover:bg-slate-700">
                      <td className="p-3 font-semibold">#{seg.id}</td>
                      <td className="p-3 font-mono text-xs">{seg.xRange}</td>
                      <td className="p-3 font-mono">{seg.slope}</td>
                      <td className="p-3 font-mono">{seg.intercept}</td>
                      <td className="p-3 font-mono">{seg.r2}</td>
                      <td className="p-3 font-mono text-xs">
                        y = {seg.slope}x + {seg.intercept}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
