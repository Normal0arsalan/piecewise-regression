import React, { useState } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, Scatter, ScatterChart, ZAxis } from 'recharts';
import { Upload, Play, Trash2 } from 'lucide-react';

export default function PiecewiseLinearFit() {
  const [points, setPoints] = useState([]);
  const [segments, setSegments] = useState([]);
  const [numSegments, setNumSegments] = useState(3);
  const [inputText, setInputText] = useState('');

  const parseInput = (text) => {
    const lines = text.trim().split('\n');
    const parsed = [];
    for (let line of lines) {
      const parts = line.trim().split(/[\s,;]+/);
      if (parts.length >= 2) {
        const x = parseFloat(parts[0]);
        const y = parseFloat(parts[1]);
        if (!isNaN(x) && !isNaN(y)) {
          parsed.push({ x, y });
        }
      }
    }
    return parsed;
  };

  const handleLoadData = () => {
    const parsed = parseInput(inputText);
    if (parsed.length > 0) {
      setPoints(parsed);
      setSegments([]);
    }
  };

  const findNearestToYAxis = (pts) => {
    let nearest = pts[0];
    let minX = Math.abs(pts[0].x);
    for (let pt of pts) {
      if (Math.abs(pt.x) < minX) {
        minX = Math.abs(pt.x);
        nearest = pt;
      }
    }
    return nearest;
  };

  const linearRegression = (pts) => {
    const n = pts.length;
    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
    
    for (let pt of pts) {
      sumX += pt.x;
      sumY += pt.y;
      sumXY += pt.x * pt.y;
      sumX2 += pt.x * pt.x;
    }
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    
    return { slope, intercept };
  };

  const calculateR2 = (pts, slope, intercept) => {
    const meanY = pts.reduce((sum, pt) => sum + pt.y, 0) / pts.length;
    let ssRes = 0, ssTot = 0;
    
    for (let pt of pts) {
      const predicted = slope * pt.x + intercept;
      ssRes += Math.pow(pt.y - predicted, 2);
      ssTot += Math.pow(pt.y - meanY, 2);
    }
    
    return 1 - (ssRes / ssTot);
  };

  const performSegmentation = () => {
    if (points.length < 2) return;

    const sorted = [...points].sort((a, b) => a.x - b.x);
    const segmentSize = Math.floor(sorted.length / numSegments);
    const newSegments = [];

    for (let i = 0; i < numSegments; i++) {
      const start = i * segmentSize;
      const end = i === numSegments - 1 ? sorted.length : (i + 1) * segmentSize;
      const segmentPoints = sorted.slice(start, end);
      
      if (segmentPoints.length >= 2) {
        const { slope, intercept } = linearRegression(segmentPoints);
        const r2 = calculateR2(segmentPoints, slope, intercept);
        
        const xStart = segmentPoints[0].x;
        const xEnd = segmentPoints[segmentPoints.length - 1].x;
        const yStart = slope * xStart + intercept;
        const yEnd = slope * xEnd + intercept;
        
        newSegments.push({
          id: i + 1,
          slope: slope.toFixed(4),
          intercept: intercept.toFixed(4),
          r2: r2.toFixed(4),
          xRange: `[${xStart.toFixed(2)}, ${xEnd.toFixed(2)}]`,
          lineData: [
            { x: xStart, y: yStart },
            { x: xEnd, y: yEnd }
          ]
        });
      }
    }

    setSegments(newSegments);
  };

  const generateSampleData = () => {
    const sample = [];
    for (let i = 0; i < 50; i++) {
      const x = i * 0.5;
      let y;
      if (x < 8) {
        y = 2 * x + 3 + (Math.random() - 0.5) * 2;
      } else if (x < 16) {
        y = -1 * x + 30 + (Math.random() - 0.5) * 2;
      } else {
        y = 0.5 * x + 5 + (Math.random() - 0.5) * 2;
      }
      sample.push({ x: x.toFixed(2), y: y.toFixed(2) });
    }
    setInputText(sample.map(p => `${p.x} ${p.y}`).join('\n'));
  };

  const nearest = points.length > 0 ? findNearestToYAxis(points) : null;

  return (
    <div className="w-full h-screen bg-gradient-to-br from-slate-900 to-slate-800 p-6 overflow-auto">
      <div className="max-w-7xl mx-auto">
        <h1 className="text-3xl font-bold text-white mb-6">Piecewise Linear Regression</h1>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
          {/* Input Section */}
          <div className="lg:col-span-1 bg-slate-800 rounded-lg p-4 shadow-xl border border-slate-700">
            <h2 className="text-xl font-semibold text-white mb-4">ورودی داده‌ها</h2>
            
            <textarea
              className="w-full h-48 bg-slate-900 text-white p-3 rounded border border-slate-600 font-mono text-sm mb-3"
              placeholder="هر خط: x y&#10;مثال:&#10;0 3&#10;1 5&#10;2 7"
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
            />
            
            <div className="flex gap-2 mb-4">
              <button
                onClick={handleLoadData}
                className="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded flex items-center justify-center gap-2"
              >
                <Upload size={18} />
                بارگذاری
              </button>
              <button
                onClick={generateSampleData}
                className="flex-1 bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded"
              >
                نمونه
              </button>
              <button
                onClick={() => { setPoints([]); setSegments([]); setInputText(''); }}
                className="bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded"
              >
                <Trash2 size={18} />
              </button>
            </div>

            <div className="mb-4">
              <label className="text-white text-sm mb-2 block">تعداد بخش‌ها (Segments)</label>
              <input
                type="number"
                min="1"
                max="10"
                value={numSegments}
                onChange={(e) => setNumSegments(parseInt(e.target.value) || 1)}
                className="w-full bg-slate-900 text-white p-2 rounded border border-slate-600"
              />
            </div>

            <button
              onClick={performSegmentation}
              disabled={points.length < 2}
              className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 text-white py-2 px-4 rounded flex items-center justify-center gap-2"
            >
              <Play size={18} />
              محاسبه خطوط
            </button>

            {nearest && (
              <div className="mt-4 bg-slate-900 p-3 rounded border border-green-500">
                <p className="text-green-400 text-sm font-semibold">نزدیک‌ترین به محور Y:</p>
                <p className="text-white text-sm">x = {nearest.x.toFixed(3)}, y = {nearest.y.toFixed(3)}</p>
              </div>
            )}

            {points.length > 0 && (
              <div className="mt-3 text-slate-400 text-sm">
                تعداد نقاط: {points.length}
              </div>
            )}
          </div>

          {/* Chart Section */}
          <div className="lg:col-span-2 bg-slate-800 rounded-lg p-4 shadow-xl border border-slate-700">
            <h2 className="text-xl font-semibold text-white mb-4">نمودار</h2>
            
            {points.length > 0 ? (
              <ScatterChart width={700} height={400}>
                <CartesianGrid strokeDasharray="3 3" stroke="#475569" />
                <XAxis type="number" dataKey="x" stroke="#94a3b8" domain={['dataMin', 'dataMax']} />
                <YAxis type="number" dataKey="y" stroke="#94a3b8" domain={['auto', 'auto']} />
                <Tooltip 
                  contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #475569' }}
                  labelStyle={{ color: '#fff' }}
                />
                <Legend />
                <Scatter name="داده‌ها" data={points} fill="#3b82f6" />
                {segments.map((seg, idx) => (
                  <Scatter
                    key={idx}
                    name={`خط ${seg.id}`}
                    data={seg.lineData}
                    fill={`hsl(${idx * 360 / segments.length}, 70%, 50%)`}
                    line={{ stroke: `hsl(${idx * 360 / segments.length}, 70%, 50%)`, strokeWidth: 3 }}
                    lineType="joint"
                    shape="circle"
                  />
                ))}
              </ScatterChart>
            ) : (
              <div className="h-96 flex items-center justify-center text-slate-500">
                داده‌ای برای نمایش وجود ندارد
              </div>
            )}
          </div>
        </div>

        {/* Results Section */}
        {segments.length > 0 && (
          <div className="bg-slate-800 rounded-lg p-4 shadow-xl border border-slate-700">
            <h2 className="text-xl font-semibold text-white mb-4">نتایج محاسبات</h2>
            <div className="overflow-x-auto">
              <table className="w-full text-left text-sm">
                <thead className="bg-slate-900 text-slate-300">
                  <tr>
                    <th className="p-3">بخش</th>
                    <th className="p-3">بازه X</th>
                    <th className="p-3">شیب (Slope)</th>
                    <th className="p-3">عرض از مبدا (Intercept)</th>
                    <th className="p-3">R² (دقت)</th>
                    <th className="p-3">معادله</th>
                  </tr>
                </thead>
                <tbody className="text-white">
                  {segments.map((seg, idx) => (
                    <tr key={idx} className="border-b border-slate-700 hover:bg-slate-700">
                      <td className="p-3 font-semibold">#{seg.id}</td>
                      <td className="p-3 font-mono text-xs">{seg.xRange}</td>
                      <td className="p-3 font-mono">{seg.slope}</td>
                      <td className="p-3 font-mono">{seg.intercept}</td>
                      <td className="p-3 font-mono">{seg.r2}</td>
                      <td className="p-3 font-mono text-xs">
                        y = {seg.slope}x + {seg.intercept}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}